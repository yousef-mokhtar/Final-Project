این برای تمام پروژه منه که میخوام تمامش رو بهت بدم
اول ستینگ
"""
Django settings for customie_store project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from logging import config
from pathlib import Path
import os
from dotenv import load_dotenv



# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Calling load_env
load_dotenv(os.path.join(BASE_DIR, ".env"))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("SECRET_KEY") 

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG") == "True"

ALLOWED_HOSTS = ['localhost', '127.0.0.1']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'orders.apps.OrdersConfig',
    'core.apps.CoreConfig',
    'accounts.apps.AccountsConfig',
    'seller.apps.SellerConfig',
    'products.apps.ProductsConfig',
    'django_extensions',
    'rest_framework',
    'drf_spectacular',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'customie_store.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'customie_store.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / "db.sqlite3",
    }
}



# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
AUTH_USER_MODEL = 'accounts.User'

REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework_simplejwt.authentication.JWTAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_SCHEMA_CLASS": "drf_spectacular.openapi.AutoSchema",
    "DEFAULT_PAGINATION_CLASS": "rest_framework.pagination.LimitOffsetPagination",
    "PAGE_SIZE": 10,
}

SPECTACULAR_SETTINGS = {
    "TITLE": "Customie Store API",
    "DESCRIPTION": "API documentation for Customie Store project",
    "VERSION": "1.0.0",
    "SERVE_INCLUDE_SCHEMA": True,
}

CELERY_BROKER_URL = "redis://127.0.0.1:6379/0"
CELERY_RESULT_BACKEND = "redis://127.0.0.1:6379/0"
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"



CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": f"redis://{os.getenv('REDIS_HOST', '127.0.0.1')}:{os.getenv('REDIS_PORT', '6379')}/1",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        },
    }
}
خب حالا سلری دات پای
import os
from celery import Celery

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'customie_store.settings')

app = Celery('customie_store')

app.config_from_object('django.conf:settings', namespace='CELERY')

app.autodiscover_tasks()
اینم اینیت دات پای
from .celery import app as celery_app

__all__ = ('celery_app',)
اینم یوارال
"""
URL configuration for customie_store project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView
from drf_spectacular.views import SpectacularAPIView, SpectacularSwaggerView, SpectacularRedocView


urlpatterns = [
    path('admin/', admin.site.urls),
    path("api/token/", TokenObtainPairView.as_view(), name="token_obtain_pair"),
    path("api/token/refresh/", TokenRefreshView.as_view(), name="token_refresh"),
    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
    path('api/schema/swagger-ui/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
    path('api/schema/redoc/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),
]
حالا میریم سراغ اپ اکانت 
مدلش
from django.db import models
from core.models import BaseModel
from django.contrib.auth.models import AbstractUser, Group, Permission


class User(AbstractUser, BaseModel):
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=11, unique=True)
    is_verified = models.BooleanField(default=False)


    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["username", "phone"]

class Address(BaseModel):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    title = models.CharField(max_length=50)
    province = models.CharField(max_length=100)
    city = models.CharField(max_length=100)
    postal_code = models.CharField(max_length=20)
    address_line = models.TextField()
    is_default = models.BooleanField(default=False)

ادمینش

from django.contrib import admin
from .models import User, Address, OTPCode
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin


@admin.register(User)
class UserAdmin(BaseUserAdmin):
    model = User
    list_display = ('username', 'email', 'phone', 'is_verified', 'is_staff', 'is_active')
    list_filter = ('is_verified', 'is_staff', 'is_active', 'groups')
    search_fields = ('email', 'username', 'phone')
    ordering = ('email',)

@admin.register(Address)
class AddressAdmin(admin.ModelAdmin):
    list_display = ('user', 'title', 'province', 'city', 'postal_code', 'is_default')
    list_filter = ('province', 'city', 'is_default')
    search_fields = ('user__email', 'title', 'city', 'province', 'postal_code')

@admin.register(OTPCode)
class OTPCodeAdmin(admin.ModelAdmin):
    list_display = ('user', 'code', 'expiration_time', 'is_verified')
    list_filter = ('is_verified',)
    search_fields = ('user__email', 'code')


سریالایزرش
from rest_framework import serializers
from .models import User, Address, OTPCode
from rest_framework_simplejwt.serializers import TokenObtainSerializer

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'email', 'phone', 'username', 'first_name', 'last_name']
        read_only_fields = ['id']

    email = serializers.EmailField(
        error_messages={"unique": "این ایمیل قبلاً ثبت شده است."}
    )

    phone = serializers.CharField(
        min_length=11,
        max_length=11,
        error_messages={
            "min_length": "شماره تلفن باید 11 رقمی باشد.",
            "max_length": "شماره تلفن باید 11 رقمی باشد.",
            "unique": "این شماره تلفن قبلاً ثبت شده است.",
        },
    )

class AddressSerializer(serializers.ModelSerializer):
    class Meta:
            model = Address
            fields = ['id', 'title', 'province', 'city', 'postal_code', 'address_line', 'is_default']
            read_only_fields = ['id', 'user']  # کاربر خودش یوزر رو ست نکنه
    
    def validate(self, attrs):
        user = self.context['request'].user
        if attrs.get('is_default'):
            Address.objects.filter(user=user, is_default=True).update(is_default=False) # خاموش کردن آدرس های پیش فرض قبلی
        return attrs
    
class OTPCodeRequestSerializer(serializers.Serializer):
    phone = serializers.CharField(
        max_length=11,
        min_length=11,
        error_messages={
            "min_length": "شماره تلفن باید 11 رقمی باشد.",
            "max_length": "شماره تلفن باید 11 رقمی باشد."
        }
    )
    email = serializers.EmailField(
        required=False,
        error_messages={"invalid": "ایمیل معتبر وارد کنید."}
    )

class OTPCodeVerifySerializer(serializers.Serializer):
    code = serializers.CharField(
        max_length=6,
        min_length=6,
        error_messages={
             "min_length": "کد OTP باید 6 رقمی باشد.",
             "max_length": "کد OTP باید 6 رقمی باشد.",
        },
    )
    phone = serializers.CharField(
        max_length=11,
        min_length=11,
        error_messages={
            "min_length": "شماره تلفن باید 11 رقمی باشد.",
            "max_length": "شماره تلفن باید 11 رقمی باشد.",
        },
    )
ویوش
from datetime import timedelta, timezone
import random
from django.shortcuts import render
from rest_framework import generics, viewsets, status
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework.response import Response
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

from accounts.tasks import send_otp_code
from .models import OTPCode, User, Address
from .serializers import UserSerializer, AddressSerializer, OTPCodeRequestSerilizer, OTPCodeVerifySerializer
from .utils import save_otp, verify_otp
from drf_spectacular.utils import extend_schema, OpenApiParameter


class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    serializer_class = UserSerializer
    permission_classes = [AllowAny]

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = serializer.save(is_verified=False)  # کاربر ثبت می‌شه ولی تأیید نشده
        return Response({
            'message': f'کاربر با موفقیت ثبت شد. لطفاً کد OTP را از طریق /api/accounts/otp/request/ درخواست کنید.',
            'user_id': user.id,
            'email': user.email,
            'phone': user.phone
        }, status=status.HTTP_201_CREATED)


class LoginView(TokenObtainPairView):
    pass

class TokenRefresh(TokenRefreshView):
    pass

class OTPRequestView(generics.GenericAPIView):
    pass


class UserProfileView(generics.RetrieveUpdateDestroyAPIView):
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]

    def get_object(self):
        return self.request.user

    # Soft delete
    def perform_destroy(self, instance):
        instance.is_deleted = True
        instance.is_active = False
        instance.save()

    


class AddressViewSet(viewsets.ModelViewSet):
    serializer_class = AddressSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return Address.objects.filter(user=self.request.user, is_deleted=False)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

    # Soft delete
    def perform_destroy(self, instance):
        instance.is_deleted = True
        instance.save()

class OTPRequestView(generics.GenericAPIView):
    serializer_class = OTPCodeRequestSerilizer
    permission_classes = [AllowAny]  # برای ثبت‌نام نیازی به لاگین نیست

    def post(self, request):
        user = request.user

        code = str(random.randint(100000, 999999))
        # expiration_time = timezone.now() + timedelta(minutes=5)
        save_otp(phone=user.phone, otp=code)
        # otp = OTPCode.objects.create(user=user, code=code, expiration_time=expiration_time)

        send_otp_code.delay(user.id, code)
        return Response({'message': 'کد OTP ارسال شد.'}, status=status.HTTP_200_OK)


class OTPVerifyView(generics.GenericAPIView):

    # خواندن اوتیپی و شماره تلفن از کاربر
    # خواندن اوتیپی از دیتابیس
    # مچ کردن این دو
    # اگر این دو باهم مچ بودن ثبت نام انجام میشه برای این کاربر
    # اگر مچ نبود ارور بده 

    serializer_class = OTPCodeVerifySerializer
    permission_classes = [AllowAny]

    @extend_schema(  # برای Swagger
        summary="Verify OTP code",
        description="Verifies the OTP code and marks the user as verified."
    )

    def post(self, request, *args, **kwargs):
        # دریافت داده‌ها از درخواست
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        phone = serializer.validated_data['phone']
        code = serializer.validated_data['code']

        if verify_otp(phone=phone, otp=code):
            try:
                user = User.objects.get(phone=phone, is_deleted=False)
                user.is_verified = True
                user.save()
                return Response(
                    {'message': 'کد OTP تأیید شد و کاربر تأیید شد.'},
                    status=status.HTTP_200_OK
                )
            except User.DoesNotExist:
                return Response(
                    {'error': 'کاربری با این شماره تلفن یافت نشد.'},
                    status=status.HTTP_404_NOT_FOUND
                )
        else:
            return Response(
                {'error': 'کد OTP نامعتبر یا منقضی شده است.'},
                status=status.HTTP_400_BAD_REQUEST
            )
تسکس دات پایش
# accounts/tasks.py
from celery import shared_task
from django.core.mail import send_mail
from accounts.models import User
import logging

logger = logging.getLogger(__name__)

@shared_task
def send_otp_code(user_id, code, recipient_email=None):
    try:
        user = User.objects.get(id=user_id)
        recipient = recipient_email or user.email
        send_mail(
            subject='کد OTP شما',
            message=f'سلام {user.username}، کد تأیید شما: {code}',
            from_email='from@test.com',
            recipient_list=[recipient],
            fail_silently=False,
        )
        logger.info(f"OTP {code} sent to {recipient}")
    except User.DoesNotExist:
        logger.error(f"User with id {user_id} not found")
    except Exception as e:
        logger.error(f"Failed to send OTP to {recipient_email or 'unknown'}: {str(e)}")
یوتیلزش
import redis
from django.conf import settings
from django.core.cache import cache

r = redis.Redis(
    host=settings.REDIS_HOST,
    port=settings.REDIS_PORT,
    db=settings.REDIS_DB,
    decode_responses=True # خروجی بجای بایت به شکل رشته
)


def save_otp(phone, otp):
    """Generate and store OTP code in Redis for 2 minutes"""
    cache.set(f"otp:{phone}", otp, 120)
    return otp


def verify_otp(phone, otp):
    """Verify the OTP stored in Redis"""
    stored = r.get(f"otp:{phone}")
    if stored and stored == otp:
        r.delete(f"otp:{phone}") 
        return True
    return False
یوارالش
from django.urls import path
from rest_framework.routers import DefaultRouter
from .views import RegisterView, LoginView, TokenRefresh, UserProfileView, AddressViewSet, OTPRequestView, OTPVerifyView

router = DefaultRouter()
router.register(r'addresses', AddressViewSet, basename='address')

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('otp/request/', OTPRequestView.as_view(), name='otp-request'),
    path('otp/verify/', OTPVerifyView.as_view(), name='otp-verify'),
    path('profile/', UserProfileView.as_view(), name='profile'),
] + router.urls

حالا میریم سراغ اپ کارت
مدلش
from django.db import models
from core.models import BaseModel
from accounts.models import User
from seller.models import StoreItem

class Cart(BaseModel):
    user = models.OneToOneField(User, on_delete= models.CASCADE, related_name='cart')
    is_active = models.BooleanField(default=True)
    def total_price(self):
        return sum([item.total_price for item in self.items.all()])
    
class CartItem(BaseModel):
    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name='items')
    store_item = models.ForeignKey(StoreItem, on_delete=models.CASCADE)
    quantity = models.PositiveIntegerField(default=1)

    class Meta:
        unique_together = ('cart', 'store_item')

    @property
    def total_price(self):
        return self.quantity * self.store_item.price
    
    def __str__(self):
        return f'{self.quantity} * {self.store_item.name}'
سریالایزرش
from rest_framework import serializers
from .models import Cart, CartItem
from seller.serializers import StoreItemSerializer
from seller.models import StoreItem


class CartItemSerializer(serializers.ModelSerializer):
    store_item = StoreItemSerializer(read_only=True)
    total_price = serializers.ReadOnlyField()

    class Meta:
        model = CartItem
        fields = ['id', 'store_item', 'quantity', 'total_price']
        read_only_fields = ['id', 'total_price']

    def validate_quantity(self, value):
        store_item_id = self.initial_data.get('store_item')

        if not store_item_id:
            raise serializers.ValidationError("محصول انتخاب نشده است.")

        try:
            store_item = StoreItem.objects.get(id=store_item_id)
        except StoreItem.DoesNotExist:
            raise serializers.ValidationError("محصول موردنظر وجود ندارد.")

        if value > store_item.stock:
            raise serializers.ValidationError("موجودی کافی نیست.")

        return value


class CartSerializer(serializers.ModelSerializer):
    items = CartItemSerializer(many=True, read_only=True)
    total_price = serializers.ReadOnlyField()
    
    class Meta:
        model = Cart
        fields = ['id', 'user', 'is_active', 'items', 'total_price']
        read_only_fields = ['id', 'user', 'total_price']
ویوش
from django.shortcuts import render
from rest_framework import viewsets, generics
from rest_framework.permissions import IsAuthenticated
from .models import Cart, CartItem
from .serializers import CartSerializer, CartItemSerializer

class CartView(generics.RetrieveAPIView):
    serializer_class = CartSerializer
    permission_classes = [IsAuthenticated]

    def get_object(self):
        return Cart.objects.get_or_create(user=self.request.user, is_active=True, is_deleted=False)[0]
        # cart, _ = Cart.objects.get_or_create(user=self.request.user, is_active=True, is_deleted=False)
        # return cart

class AddToCartView(generics.CreateAPIView):
    serializer_class = CartItemSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serilizer):
        from seller.models import StoreItem
        store_item = StoreItem.objects.get(id=self.kwargs['store_item_id'], is_deleted=False)
        cart = Cart.objects.get(user=self.request.user, is_active=True, is_deleted=False)
        serilizer.save(cart=cart, store_item=store_item)

class CartItemViewSet(viewsets.ModelViewSet):
    serializer_class = CartItemSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        cart = Cart.objects.get(user=self.request.user, is_active=True, is_deleted=False)
        return cart.items.filter(is_deleted=False)

    def perform_destroy(self, instance):
        instance.is_deleted = True
        instance.save()
حالا اپ core
فقط مدلشو زدم 
from django.db import models
from django.utils import timezone

class BaseModel(models.Model):
    created_at = models.DateTimeField(db_index=True, default=timezone.now)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)
    is_deleted = models.BooleanField(default=False)

    class Meta:
        abstract = True

حالا میریم سراغ اپ اوردر
مدلش
from django.db import models
from core.models import BaseModel
from accounts.models import Address, User
from products.models import Product
from seller.models import StoreItem

class Order(BaseModel):
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        PROCESSING = "processing", "Processing"
        SHIPPED = "shipped", "Shipped"
        COMPLETED = "completed", "Completed"
        CANCELED = "canceled", "Canceled"

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='orders')
    is_paid = models.BooleanField(default=False)
    shipping_address = models.ForeignKey(Address, on_delete=models.SET_NULL, null=True, blank=True)
    total_price = models.DecimalField(max_digits=15, decimal_places=0, default=0)
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.PENDING)
    paid_at = models.DateTimeField(null=True, blank=True)

    def calculate_total(self):
        self.total_price = sum([item.total_price for item in self.items.all()])
        self.save()

class OrderItem(BaseModel):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name='items')
    store_item = models.ForeignKey(StoreItem, on_delete=models.PROTECT)
    quantity = models.PositiveIntegerField(default=1)
    price = models.DecimalField(max_digits=15, decimal_places=0)

    class Meta:
        unique_together = ('order', 'store_item')

    @property
    def total_price(self):
        return self.quantity * self.price

class Invoice(BaseModel):
    class Status(models.TextChoices):
        UNPAID = "unpaid", "Unpaid"
        PAID = "paid", "Paid"
        CANCELED = "canceled", "Canceled"
    order = models.OneToOneField(Order, on_delete=models.CASCADE, related_name='invoice')
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='invoices')
    invoices_number = models.CharField(max_length=20, unique=True)
    amount = models.DecimalField(max_digits=15, decimal_places=0)
    tax = models.DecimalField(max_digits=15, decimal_places=0, default=0)
    discount = models.DecimalField(max_digits=15, decimal_places=0,default=0)
    status = models.CharField(max_length=20, choices=Status.choices, default=Status.UNPAID)
    issued_at = models.DateTimeField(auto_now_add=True)
    paid_at = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return f'Invoice {self.invoices_number} - {self.user.email}'
    
    def final_amount(self):
        self.amount = self.order.total_price + self.tax - self.discount
        return self.amount
سریالایزرش
from rest_framework import serializers
from .models import Order, OrderItem, Invoice

class OrderItemSerializer(serializers.ModelSerializer):
    total_price = serializers.ReadOnlyField()

    class Meta:
        model = OrderItem
        fields = ['id', 'store_item', 'quantity', 'price', 'total_price']
        read_only_fields = ['id', 'price', 'total_price']


class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True, read_only=True)
    total_price = serializers.ReadOnlyField()
    
    class Meta:
        model = Order
        fields = ['id', 'user', 'shipping_address', 'total_price', 'status', 'is_paid', 'paid_at', 'items']
        read_only_fields = ['id', 'user', 'total_price', 'is_paid', 'paid_at']

    def validate(self, data):
        if not data.get('shipping_address'):
            raise serializers.ValidationError('آدرس ارسال الزامی است.')
        return data
   
    
class InvoiceSerializer(serializers.ModelSerializer):
    final_amount = serializers.ReadOnlyField()

    class Meta:
        model = Invoice
        fields = ['id', 'order', 'user', 'invoices_number', 'amount', 'tax', 'discount', 'status', 'issued_at', 'paid_at', 'final_amount']
        read_only_fields = ['id', 'order', 'user', 'invoices_number', 'amount', 'issued_at', 'paid_at', 'final_amount']
ویوش
from django.shortcuts import render
from rest_framework import generics, viewsets
from rest_framework.permissions import IsAuthenticated, IsAdminUser
from .models import Order, OrderItem, Invoice
from .serializers import OrderSerializer, InvoiceSerializer
from cart.models import Cart


class MyOrderView(viewsets.ReadOnlyModelViewSet):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return Order.objects.filter(user=self.request.user, is_deleted=False)


class CheckoutView(generics.CreateAPIView):
    serializer_class = OrderSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        cart = Cart.objects.get(user=self.request.user, is_active=True, is_deleted=False)
        order = serializer.save(user=self.request.user)
        for item in cart.items.filter(is_deleted=False):
            OrderItem.objects.create(order=order,  store_item = item.store_item, quantity=item.quantity, price=item.store_item.price)
            order.calculate_total()
            Invoice.objects.create(order=order, user=self.request.user, invoices_number=f'INV-{order.id}', amount=order.total_price)
            cart.is_active = False
            cart.save()


class AdminOrderViewSet(viewsets.ModelViewSet):
    queryset = Order.objects.filter(is_deleted=False)
    serializer_class = OrderSerializer
    permission_classes = [IsAdminUser]

    def perform_destroy(self, instance):
        instance.is_deleted = True
        instance.save()

اینم برای اپ پیمنت
مدلش
from django.db import models
from core.models import BaseModel
from orders.models import Order

class Payment(BaseModel):
    class Status(models.TextChoices):
        PENDING = "pending", "Pending"
        SUCCESS = "success", "Success"
        FAILED = "failed", "Failed"
    
    orders = models.OneToOneField(Order, on_delete=models.CASCADE, related_name='payment')
    amount = models.DecimalField(max_digits=15, decimal_places=0)
    status = models.CharField(max_length=10, choices=Status.choices, default=Status.PENDING)
    paid_at = models.DateField(null=True, blank=True)
    transaction_id = models.CharField(max_length=100, null=True, blank=True)

    def __str__(self):
        return f'Payment for Order #{self.orders.id} - {self.status}'
سریالایزرش
from rest_framework import serializers
from .models import Payment

class PaymentSerializer(serializers.ModelSerializer):
    class Meta:
            model = Payment
            fields = ['id', 'orders', 'amount', 'status', 'paid_at', 'transaction_id']
            read_only_fields = ['id', 'orders', 'amount', 'paid_at', 'transaction_id']
    
    def validate_amount(self, value):
        if value <= 0:
            raise serializers.ValidationError('مبلغ پرداخت باید مثبت باشد.')
        return value
    
    def validate(self, data):
        order = data.get('orders')
        if order and order.is_paid: # گذاشتن اوردر برای رفع AttributeError
            raise serializers.ValidationError('این سفارش قبلاً پرداخت شده است.')
        return data
    ویوش رو هم نزدم هنوز


حالا اپ پروداکت 
مدلش
from django.db import models
from core.models import BaseModel


class Category(BaseModel):
    name = models.CharField(max_length=100)
    description = models.TextField(null=True, blank=True)

class Product(BaseModel):
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True)
    name = models.CharField(max_length=200)
    description = models.TextField(null=True, blank=True)
    brand = models.CharField(max_length=100, null=True, blank=True)
    image = models.ImageField(upload_to='products/', null=True, blank=True)


    def __str__(self):
        return self.name
    
class ProductImage(models.Model):
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='images')
    image = models.ImageField(upload_to='products/', blank=True, null=True)
    alt_text = models.CharField(max_length=100, blank=True)

    def __str__(self):
        return f"{self.product.name} - {self.alt_text or 'Image'}"

سریالایزرش
from rest_framework import serializers
from .models import Category, Product, ProductImage

class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ['id', 'name', 'description']
        read_only_fields = ['id']

    def validate_name(self, value):
        if Category.objects.filter(name=value).exists():
            raise serializers.ValidationError('این نام دسته‌بندی قبلاً وجود دارد.')
        return value
    

class ProductImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = ProductImage
        fields = ['id', 'image', 'alt_text']
        read_only_fields = ['id']
    

class ProductSerializer(serializers.ModelSerializer):
    category = CategorySerializer(read_only=True)
    image = ProductImageSerializer(many=True, read_only=True)

    class Meta:
        model = Product
        fields = ['id', 'category', 'name', 'description', 'brand', 'image', 'images']
        read_only_fields = ['id']

    def validate(self, data):
        if not data.get('name') or not data.get('description'):
            raise serializers.ValidationError('نام و توضیحات محصول الزامی است.')
        return data
برای اینم ویو نداریم  هنوز

بریم سراغ اپ ریویو
from django.db import models
from core.models import BaseModel
from accounts.models import User
from products.models import Product

class Review(BaseModel):
    class Rating(models.IntegerChoices):
        ONE = 1, "1"
        TWO = 2, "2"
        THREE = 3, "3"
        FOUR = 4, "4"
        FIVE = 5, "5"

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="reviews")
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name="reviews")
    rating = models.PositiveSmallIntegerField(choices=Rating.choices)
    text = models.TextField(blank=True, null=True)
    is_approved = models.BooleanField(default=False)

    class Meta:
        unique_together = ("user", "product")
        ordering = ["-created_at"]

    def __str__(self):
        return f"{self.user.email} - {self.product.name} ({self.rating}⭐)"
سریالایزرش
from rest_framework import serializers
from .models import Review

class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = ['id', 'user', 'product', 'rating', 'text', 'is_approved']
        read_only_fields = ['id', 'user', 'is_approved']
    
    def validate_rating(self, value):
        if value < 1 or value > 5:
            raise serializers.ValidationError("امتیاز باید بین 1 تا 5 باشد.")
        return value
    
    def validate(self, data):
            user = self.context['request'].user
            product = data.get('product')
            if Review.objects.filter(user=user, product=product).exists():
                raise serializers.ValidationError("شما قبلاً برای این محصول نظر ثبت کرده‌اید.")
            return data
ویوش
from django.shortcuts import render
from rest_framework import generics 
from rest_framework.permissions import IsAuthenticated
from products.models import Product
from .models import Review
from .serializers import ReviewSerializer

class CreateReviewView(generics.CreateAPIView):
    serializer_class = ReviewSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        product_id = self.kwargs['id']
        product = Product.objects.get(id=product_id, is_deleted=False)
        serializer.save(user=self.request.user, product=product)

برای اپ سلر
مدلش
from django.db import models
from core.models import BaseModel
from accounts.models import User
from products.models import Category, Product


class Store(BaseModel):
    owner = models.ForeignKey(User, on_delete=models.CASCADE, )
    name = models.CharField(max_length=100)
    description = models.TextField()
    address = models.TextField()

class StoreItem(BaseModel):
    store = models.ForeignKey(Store, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, blank=True)
    name = models.CharField(max_length=100)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=0)
    stock = models.PositiveIntegerField()
    
سریالایزرش
from rest_framework import serializers
from .models import Store, StoreItem
from products.serializers import ProductImageSerializer, CategorySerializer

class StoreSerializer(serializers.ModelSerializer):
    class Meta:
        model = Store
        fields = ['id', 'owner', 'name', 'description', 'address']
        read_only_fields = ['id', 'owner']


class StoreItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = StoreItem
        fields = ['id', 'store', 'product', 'category', 'name', 'description', 'price', 'stock']
        read_only_fields = ['id']

    def validate_price(self, value):
        if value <= 0:
            raise serializers.ValidationError('قیمت محصول باید مثبت باشد.')
        return value
    
    def validate_stock(self, value):
        if value < 0:
            raise serializers.ValidationError('موجودی نمی‌تواند منفی باشد.')
        

    def validation_information(self, request):
        pass
ویوش
from django.shortcuts import render
from rest_framework import generics, viewsets
from rest_framework.permissions import IsAuthenticated
from .models import Store, StoreItem
from serializers import StoreSerializer, StoreItemSerializer

class RegisterAsSellerView(generics.CreateAPIView):
    serializer_class = StoreSerializer
    permission_classes = [IsAuthenticated]

    def perform_create(self, serializer):
        serializer.save(owner=self.request.user)


class MyStoreView(generics.RetrieveUpdateAPIView):
    serializer_class = StoreSerializer
    permission_classes = [IsAuthenticated]

    def get_object(self):
        return Store.objects.get(owner=self.request.user, is_deleted=False)
    

class StoreItemViewSet(viewsets.ModelViewSet):
    serializer_class = StoreItem
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return StoreItem.objects.filter(store__owner=self.request.user, is_deleted=False)
    
    def perform_destroy(self, instance):
        instance.is_deleted = True
        instance.save()

خب حالا اینم بگم من فقط ادمین اپ اکانت رو دادم و بقیه رو هم نصفه نیمه نوشتم ولی فعلا نیاز به نوشتن ادمین نیستو حالا اگه در قالب یک فایل بقیه ادمین هرو هم بدی اکیع
از اونور حالا ینم بگم که این تسکی بود که خود منتورمون بهمون داده بود

کاستومی بک اند
کاستومی بک اند یک سرویس بکاند برای مدیریت یک پلتفرم چند فروشگاهی است.
این سیستم امکانات مورد نیاز مشتریان، فروشندگان و مدیران را برای تعامل با هم
فراهم میکند.
تحویل
- برای پروژه یک README کامل و مناسب نوشته شود )نصب، راهاندازی،
متغیرهای محیطی، اجرای تستها(.
- ERD( نمودار روابط موجودیتها( ترسیم شود.
- ریپوی گیتهاب پروژه تا پایان کار باید Private باقی بماند.
- استاد و مدرسان دوره بهعنوان collaborator به ریپو اضافه شوند و پس از
انجام، در گروه اطالع داده شود.
نکات فنی
- رعایت اصول پایهی Git الزامی است: کامیتهای کوچک و مرتب، پیامهای
واضح، و استفاده از برنچینگ همراه با Request Pull
- اپلیکیشن core و Delete Logical الزامی می باشد.
- برای دیپلوی الزمه از docker و compose docker استفاده کنید.
- تنظیمات پروژه باید تمیز با استفاده از .env تفکیک شده باشد.
- داشتن داکیومنتیشن به روز الزامی می باشد )شامل response ،request و...(
- بهکارگیری Redis و Celery بر اساس نیازهای پروژه الزامی است
- مطالعه جنگو HackSoft برای BaseModel
Django Styleguide - Base Model
2
نیازمندیهای اصلی )اجباری(
احراز هویت و حساب کاربری
● کاربر بتواند ثبتنام و ورود کند )با ایمیل/شماره تلفن(
● ورود با token JWT انجام میشود.
● امکان ورود و تایید از طریق OTP فراهم باشد.
● کاربر باید بتواند اطالعات پروفایل خود را مشاهده و ویرایش کند.
● کاربر باید بتواند آدرسهای خود را ثبت، ویرایش و حذف کند.
● کاربر باید بتواند وضعیت سفارشهای اخیر و تاریخچه سفارشهای خود را در پروفایل کاربری
مشاهده کند.
● نوشتن تست برای این app الزامی است
فروشنده و فروشگاه
● هر کاربر بتواند درخواست تبدیل به فروشنده بدهد.
● فروشنده یک فروشگاه داشته باشد که شامل مشخصات و آدرس است.
● فروشنده بتواند سفارشهایی که شامل محصوالت اوست را مشاهده و وضعیت هر آیتم سفارش را
تغییر دهد.
● نوشتن تست برای این app الزامی است.
محصوالت و دستهبندیها
● محصوالت در دستهبندیهای جا بگیرند
● محصول شامل نام، توضیحات، دسته، تصاویر، موجودی و قیمت باشد.
● هر محصول میتواند توسط چند فروشگاه عرضه شود.
● کاربران بتوانند محصوالت را مشاهده، جستجو و فیلتر کنند.
● کاربران بتوانند برای محصوالت نظر و امتیاز ثبت کنند.
● نوشتن تست برای این app اختیاری است.
3
سبد خرید و سفارش
● کاربر بتواند محصول را از طریق StoreItem
1
به سبد خرید اضافه کند.
● مجموع مبلغ و تخفیف در سبد خرید محاسبه شود.
● کاربر باید بتواند سبد خرید را به سفارش تبدیل کند )Checkout).
● هر سفارش شامل آدرس و آیتمهای سفارش است.
● نوشتن تست برای این app اختیاری است.
پرداخت
● ایجاد رکورد پرداخت برای هر سفارش.
● تغییر وضعیت سفارش بعد از تایید پرداخت.
● نوشتن تست برای این app اختیاری است.
)Admin Panel - API( مدیریت
● ادمین بتواند کاربران را مدیریت کند )لیست، ویرایش، حذف(.
● ادمین بتواند دستهبندیها را مدیریت کند.
● ادمین بتواند سفارشها و پرداختها را مدیریت کند.
● نوشتن تست برای این app اختیاری است.
مدیریت Panel Admin جنگو
● تغییر عنوان )title )پیشفرض "Administration Django "به نام پروژه
● تغییر لوگو و رنگبندی مطابق برندینگ پروژه
● تغییر متن فوتر و هدر برای نمایش اطالعات سازمان یا پروژه
تأیید گروهی سفارشها، تغییر وضعیت چند آیتم
● پیادهسازی Actionهای مدیریتی روی مدلها مثالً
همزمان، فعال/غیرفعال کردن دستهای کاربران یا محصوالت
نمایش آدرسهای کاربر داخل صفحهی User)
● نمایش Inline برای روابط )مثالً
● استفاده از fields_search ،filter_list ،display_list برای کاربری بهتر )اختیاری(
● فیلترهای پیشرفته برای جستجو روی کاربران، سفارشها و پرداختها )اختیاری(
اسم مدلی که بین فروشگاه و محصول رابطه برقرار میکند :StoreItem 1
4
نقشه API
احراز هویت و امنیت
● ورود
(Login): /api/accounts/login/ → دریافت access و refresh token
● ثبتنام
(Register): /api/accounts/register/
● جریان OTP:
/OTP: /api/accounts/request-otp درخواست○
/OTP: /api/accounts/verify-otp تأیید○
/api/accounts/token/refresh/ :توکن رفرش●
مدیریت کاربران
● پروفایل من: /myuser/api/ → مشاهده، ویرایش یا حذف حساب کاربری
● آدرسها: /address/myuser/api/ → مدیریت آدرسهای کاربر
5
● ثبتنام به عنوان فروشنده: /seller_as_register/myuser/api/ → تبدیل کاربر به فروشنده و
ایجاد فروشگاه
مدیریت کاربران توسط ادمین
● /users/admin/api/ → لیست، مشاهده، ویرایش و حذف کاربران
دستهبندیها
● عمومی: /categories/api/ → مشاهده لیست دستهبندیها
● مدیریتی
(Admin): /api/admin/categories/ → کامل عملیات CRUD دستهبندیها روی
فروشگاهها
● فروشگاههای عمومی: /stores/api/ → مشاهده فروشگاهها
● فروشگاه من )برای فروشندهها(: /mystore/api/ → مدیریت فروشگاه، آدرسها و کاالها
● مدیریت فروشگاهها توسط ادمین: از طریق ماژولهای کاربران و محصوالت قابل دسترسی است
سبد خرید
● /mycart/api/ → دریافت اطالعات سبد خرید جاری کاربر
سبد به کاال افزودن → /{api/mycart/add_to_cart/{store_item_id/ ●
6
● /items/mycart/api/ → مدیریت اقالم سبد خرید )مشاهده، بهروزرسانی، حذف(
سفارشها
● سفارشهای کاربر: /myorders/api/ → مشاهده سفارشهای ثبتشده توسط کاربر
● تسویه حساب
تبدیل سبد خرید به سفارش → /checkout/orders/api/ :)Checkout(
● مدیریت سفارشها توسط ادمین: /orders/api/
پرداختها
● /payments/api/ → ایجاد یا مشاهده پرداختها
پرداخت فرآیند آغاز → /api/payments/{id}/start/ ●
● /verify/payments/api/ → بررسی نتیجه پرداخت از سمت درگاه )Zarinpal)
نظرات و امتیازات
/api/products/{id}/review_create/ :محصوالت●
/api/stores/{id}/review_create/ :فروشگاهها●
و اینکه میخوام ببینم دیتابیسه باید کجای پروژه رو پیش ببرم و اینکه کجاها ناقصه و کلا چجوری پیش برم و این تسک های پروژس که عکس فرستادم و اینکه